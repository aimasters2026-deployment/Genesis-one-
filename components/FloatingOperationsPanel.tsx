import React, { useState, useEffect, useRef } from 'react';
import { Trash2, Scaling, Droplet, AlignCenter, Palette, Mic, Loader2 } from 'lucide-react';
import { CanvasElement, CANVAS_SIZE, ElementType } from '../types';

interface FloatingOperationsPanelProps {
  selectedElements: CanvasElement[];
  onDelete: () => void;
  onUpdate: (id: string, updates: Partial<CanvasElement>) => void;
  onVoiceCommand: (audioBlob: Blob) => void;
  isProcessing: boolean;
  zoom: number;
  pan: { x: number; y: number };
}

const FloatingOperationsPanel: React.FC<FloatingOperationsPanelProps> = ({
  selectedElements,
  onDelete,
  onUpdate,
  onVoiceCommand,
  isProcessing,
  zoom,
  pan
}) => {
  const [activeControl, setActiveControl] = useState<'scale' | 'opacity' | 'color' | null>(null);
  const [windowSize, setWindowSize] = useState({ width: window.innerWidth, height: window.innerHeight });
  
  // Recording State
  const [isRecording, setIsRecording] = useState(false);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<BlobPart[]>([]);

  useEffect(() => {
    const handleResize = () => setWindowSize({ width: window.innerWidth, height: window.innerHeight });
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const startRecording = async () => {
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error("Audio recording is not supported in this browser or requires a secure context (HTTPS).");
      }

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      chunksRef.current = [];
      
      mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) chunksRef.current.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: 'audio/webm' }); 
        onVoiceCommand(blob);
        stream.getTracks().forEach(track => track.stop());
      };
      
      mediaRecorder.start();
      setIsRecording(true);
    } catch (err: any) { 
        console.error("Mic error:", err); 
        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError' || err.message?.includes('Permission denied')) {
            alert("Microphone permission was denied. Please allow microphone access in your browser address bar.");
        } else {
            alert(`Microphone error: ${err.message || 'Unknown error'}`);
        }
    }
  };

  const stopRecording = () => { 
      if (mediaRecorderRef.current && isRecording) { 
          mediaRecorderRef.current.stop(); 
          setIsRecording(false); 
      } 
  };

  if (selectedElements.length === 0) return null;

  // Calculate bounding box of selection
  const minX = Math.min(...selectedElements.map(el => el.x));
  const minY = Math.min(...selectedElements.map(el => el.y));
  const maxX = Math.max(...selectedElements.map(el => el.x + el.width));
  // const maxY = Math.max(...selectedElements.map(el => el.y + el.height));
  
  const width = maxX - minX;
  const centerX = minX + width / 2;
  
  // Transform to screen space
  const rawScreenX = centerX * zoom + pan.x;
  const rawScreenY = minY * zoom + pan.y;

  // Clamping Logic
  const panelWidth = 260; // Increased width for mic button
  const panelHeight = 60;
  const margin = 20;

  // Keep X within screen bounds
  const screenX = Math.min(Math.max(rawScreenX, panelWidth / 2 + margin), windowSize.width - panelWidth / 2 - margin);
  
  // Keep Y within screen bounds. Prefer top, flip to bottom if too high.
  let screenY = rawScreenY - 80;
  if (screenY < margin) {
      // Flip to bottom of selection if top is clipped
      const elementBottomScreenY = (minY + Math.max(...selectedElements.map(el => el.height))) * zoom + pan.y;
      screenY = elementBottomScreenY + 20;
  }

  const primaryElement = selectedElements[0];

  const handleScaleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const scaleFactor = parseFloat(e.target.value);
    const newWidth = scaleFactor;
    const aspect = primaryElement.height / primaryElement.width;
    
    onUpdate(primaryElement.id, {
        width: newWidth,
        height: newWidth * aspect
    });
  };

  const handleOpacityChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      onUpdate(primaryElement.id, { opacity: parseFloat(e.target.value) });
  };

  const handleAlignCenter = () => {
    selectedElements.forEach(el => {
        onUpdate(el.id, {
            x: CANVAS_SIZE.width / 2 - el.width / 2,
            y: CANVAS_SIZE.height / 2 - el.height / 2
        });
    });
  };

  const handleColorChange = (color: string) => {
    selectedElements.forEach(el => {
        if (el.type === ElementType.TEXT) {
             onUpdate(el.id, { style: { ...el.style, color: color } });
        } else {
             onUpdate(el.id, { style: { ...el.style, backgroundColor: color } });
        }
    });
  };

  const getCurrentColor = () => {
      if (primaryElement.type === ElementType.TEXT) {
          return primaryElement.style?.color || '#ffffff';
      }
      return primaryElement.style?.backgroundColor || '#cbd5e1';
  }

  const PRESET_COLORS = [
      '#0f172a', '#334155', '#475569', '#94a3b8', '#cbd5e1', '#f8fafc', '#ffffff', 
      '#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', '#06b6d4', '#3b82f6', 
      '#6366f1', '#8b5cf6', '#d946ef', '#f43f5e' 
  ];

  return (
    <div 
        className="absolute z-[25] flex flex-col items-center gap-2 transition-all duration-100 ease-out"
        style={{
            left: screenX,
            top: screenY,
            transform: 'translateX(-50%)'
        }}
    >
        {/* Main Toolbar */}
        <div className="flex items-center gap-1 p-1.5 bg-white dark:bg-slate-800 rounded-full shadow-xl border border-slate-200 dark:border-slate-700 animate-in zoom-in duration-200">
            
            {/* NLP Microphone Button */}
            <button
                onClick={isRecording ? stopRecording : startRecording}
                disabled={isProcessing}
                className={`
                    p-2 rounded-full transition-colors flex items-center justify-center
                    ${isRecording 
                        ? 'bg-red-500 text-white animate-pulse shadow-red-500/30 shadow-lg' 
                        : 'text-indigo-600 dark:text-indigo-400 bg-indigo-50 dark:bg-indigo-900/30 hover:bg-indigo-100 dark:hover:bg-indigo-900/50'
                    }
                    ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}
                `}
                title="Edit with Voice (AI)"
            >
                {isProcessing ? <Loader2 size={18} className="animate-spin" /> : <Mic size={18} />}
            </button>

            <div className="w-px h-4 bg-slate-300 dark:bg-slate-600 mx-1" />

            <button 
                onClick={handleAlignCenter}
                className="p-2 rounded-full text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors"
                title="Align to Center of Artboard"
            >
                <AlignCenter size={18} />
            </button>

            <div className="w-px h-4 bg-slate-300 dark:bg-slate-600 mx-1" />

            <button 
                onClick={() => setActiveControl(activeControl === 'color' ? null : 'color')}
                className={`p-2 rounded-full transition-colors ${activeControl === 'color' ? 'bg-indigo-600 text-white' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700'}`}
                title="Color"
            >
                <Palette size={18} />
            </button>

            <button 
                onClick={() => setActiveControl(activeControl === 'scale' ? null : 'scale')}
                className={`p-2 rounded-full transition-colors ${activeControl === 'scale' ? 'bg-indigo-600 text-white' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700'}`}
                title="Scale"
            >
                <Scaling size={18} />
            </button>

            <button 
                onClick={() => setActiveControl(activeControl === 'opacity' ? null : 'opacity')}
                className={`p-2 rounded-full transition-colors ${activeControl === 'opacity' ? 'bg-indigo-600 text-white' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700'}`}
                title="Opacity"
            >
                <Droplet size={18} />
            </button>

            <div className="w-px h-4 bg-slate-300 dark:bg-slate-600 mx-1" />

            <button 
                onClick={onDelete}
                className="p-2 rounded-full text-red-500 hover:bg-red-50 dark:hover:bg-red-900/30 transition-colors"
                title="Delete"
            >
                <Trash2 size={18} />
            </button>
        </div>

        {/* Pop-out Sliders */}
        {activeControl === 'opacity' && (
            <div className="bg-white dark:bg-slate-800 p-3 rounded-xl shadow-xl border border-slate-200 dark:border-slate-700 animate-in slide-in-from-bottom-2 w-48">
                <div className="flex justify-between text-xs text-slate-500 mb-1">
                    <span>Opacity</span>
                    <span>{(primaryElement.opacity * 100).toFixed(0)}%</span>
                </div>
                <div className="relative h-6 flex items-center">
                    {/* Nozzle Visual Metaphor */}
                    <div className="absolute left-0 top-1/2 -translate-y-1/2 w-full h-1 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
                        <div className="h-full bg-indigo-500" style={{ width: `${primaryElement.opacity * 100}%` }} />
                    </div>
                    <input 
                        type="range" 
                        min="0" 
                        max="1" 
                        step="0.01" 
                        value={primaryElement.opacity} 
                        onChange={handleOpacityChange}
                        className="absolute inset-0 w-full opacity-0 cursor-pointer"
                    />
                    <div 
                        className="pointer-events-none absolute w-4 h-4 bg-white border-2 border-indigo-500 rounded-full shadow transition-all"
                        style={{ left: `calc(${primaryElement.opacity * 100}% - 8px)` }}
                    />
                </div>
            </div>
        )}

        {activeControl === 'scale' && (
             <div className="bg-white dark:bg-slate-800 p-3 rounded-xl shadow-xl border border-slate-200 dark:border-slate-700 animate-in slide-in-from-bottom-2 w-48">
                <div className="flex justify-between text-xs text-slate-500 mb-1">
                    <span>Size</span>
                    <span>{Math.round(primaryElement.width)}px</span>
                </div>
                <input 
                    type="range" 
                    min="10" 
                    max="1000" 
                    value={primaryElement.width} 
                    onChange={handleScaleChange}
                    className="w-full h-1 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                />
            </div>
        )}

        {activeControl === 'color' && (
            <div className="bg-white dark:bg-slate-800 p-3 rounded-xl shadow-xl border border-slate-200 dark:border-slate-700 animate-in slide-in-from-bottom-2 grid grid-cols-7 gap-2">
                {PRESET_COLORS.map(color => (
                    <button
                        key={color}
                        onClick={() => handleColorChange(color)}
                        className={`w-6 h-6 rounded-full border border-slate-200 dark:border-slate-600 shadow-sm transition-transform hover:scale-110 ${getCurrentColor() === color ? 'ring-2 ring-indigo-500 ring-offset-2 dark:ring-offset-slate-800' : ''}`}
                        style={{ backgroundColor: color }}
                        title={color}
                    />
                ))}
                <label className="w-6 h-6 rounded-full border border-slate-200 dark:border-slate-600 shadow-sm flex items-center justify-center cursor-pointer hover:scale-110 relative overflow-hidden bg-gradient-to-br from-red-500 via-green-500 to-blue-500" title="Custom Color">
                    <input 
                        type="color" 
                        value={getCurrentColor()}
                        onChange={(e) => handleColorChange(e.target.value)}
                        className="opacity-0 absolute inset-0 w-full h-full cursor-pointer"
                    />
                </label>
            </div>
        )}
    </div>
  );
};

export default FloatingOperationsPanel;